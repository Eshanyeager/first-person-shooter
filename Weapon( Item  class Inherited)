              /********* Header File *********/
              
              
#pragma once


#include "CoreMinimal.h"
#include "Item.h"
#include "AmmoType.h"
#include "Weapon.Generated.h"

UENUM()
class enum EWeaponType : Uint8
{
   EWT_SubmachineGun UMETA(DisplayName = "SubmachineGun"),
   EWT_AssaultRifle UMETA(DisplayName = "AssaultRifle"), 
   
   EWT_Max UMETA(DisplayName = "DefaultMax"), 
};
UCLASS()
class Shooter_API AWeapon : public AItem
{
    GENERATED_BODY()
    
public:
    AWeapon();
    
virtual void Tick(float DeltaTime) override;

protected:
     void StopFalling();
    

private:
    FTimerHandle ThrowWeaponTimer;
    float ThrowWeaponTime;
    bool bFalling;
    
    // Ammo count for this weapon
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weapon Properties", meta=(AllowPeivateAccess = "true")) 
    int32 Ammo;
    
    // Weapon Types
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Weapon Properties", meta = (AllowPrivateAccess = "true")) 
    EWeaponType WeaponType;
    
    // Ammo types
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Weapon Properties", meta = (AllowPrivateAccess = "true")) 
    EAmmoType AmmoType;
    
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Weapon Properties", meta = (AllowPrivateAccess = "true")) 
    FName ReloadMontageSection;

public:
   void ThrowWeapon();
   
   ForceInline int32 GetAmmo() const {return Ammo;}
   // Called from Shooter Character Class when firing
   void DecrementAmmo();
   
   ForceInline EWeaponType GetWeaponType() const {return WeaponType;}
   ForceInline EAmmoType GetAmmoType() const {return AmmoType;}
   ForceInline FName GetReloadMontageSection() const {return ReloadMontageSection;}

};




             /******** Cpp File *********/
        
#include "Weapon.h"


AWeappon()::AWeapon():
ThrowWeaponTime(0.7f),
bFalling(false), 
Ammo(0), 
WeaponType(EWeaponType::EWT_SubmachineGun),
AmmoType(EAmmoType::EAT_9mm),
ReloadMontageSection(FName(TEXT("Reload SMG"))),
{
   PrimaryActorTick. bCanEverTick = true;
}
void AWeapon::Tick(flaot DeltaTime)
{
   Super::Tick(DeltaTime) ;
   
   // Keep the Weapon upright
   if(GetItemState() == EItemState::EIS_Falling && bFalling) 
   {
       FRotator MeshRotation{ GetItemMesh()->GetComponentRotation().Yaw, 0.f};
       GetItemMesh()->SetWorldRotation(MeshRotation, false, nullptr, 
       ETeleportType::TeleportPhysics);
   }
}

void AWeapon::ThrowWeaponTime() 
{
   FRotator MeshRotation{ 0.f, GetItemMesh()->GetComponentRotation.().Yaw, 0.f};
   GetItemMesh()->SetWorldRotation(MeshRotation, false, nullptr, ETeleportType::TelePortPhysics) ;
   
   const FVector MeshForward{ GetItemMesh()->GetForwardVector()};
   const FVrctor MeshRight{ GetItemMesh()->GetRightVector()};
   // Direction in wich weapon thrown
   FVector ImpulseDirection = MeshRight.RotateAngleAxis{ -20.f, MeshForward};
   
   float RandomRotation{30.f};
   ImpulseDirection = ImpusleDirection.RotateAngleAxis(RandomRotation, FVector{0.f, 0.f, 1.f}) ;
   ImpulseDirection *= 20'000.f;
   GetItemMesh()->AddImpulse(ImpulseDirection);
   
   bFalling = true;
   GetWorldTimerManager().SetTimer(
   ThrowWeaponTimer, 
   this, 
   &AWeapon::StopFalling, 
   ThrowWeaponTime);
}

void AWeapon::StopFalling()
{
    bStopFalling = false;
    SetItemState(EItemState::EIS_Pickup);
}

void AWeapon::DecrmentAmmo()
{
    if(Ammo - 1 <= 0)
    {
       Ammo = 0;
    }
    else
    {
       --Ammo;
    }
}




















